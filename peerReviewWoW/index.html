<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>PSE Development WoW</title>

		<meta name="description" content="Why do I keep getting into these problems?">
		<meta name="author" content="Carmen Jiménez">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>PSE Development Way of Working</h1>
					<h3>How we work... <span class="fragment roll-in">and most important, why we do it that way</span></h3>
          <p>
	          <small>Carmen (cjc@tokbox.com)</small>
					</p>
				</section>
				<section>
					<section>
						<h2>What's this about?</h2>
          </section>
          <section>
            <h3>Developing software and having fun</h3>
            <p>AKA, developing software in a way that:
              <ul>
                <li class="fragment roll-in">
                  Allows more than one developer to have inkling of how any part of the code is implemented...
                  <span class="fragment roll-in">... and why it is that way.</span>
                </li>
                <li class="fragment roll-in">Gives everybody a sense of ownership of the code.</li>
                <li class="fragment roll-in">And maybe makes us commit less errors!. More eyes on the code means a better probability of catching bugs before they bite you.</li>
                <li class="fragment roll-in">Code that has the strenghts of all the team.</li>
              </ul>
            </p>
          </section>
          <section>
						<h3>Or rather...</h3>
          </section>
          <section>
						<h2>What is this NOT about?</h2>
          </section>
          <section>
						<h2>Forcing you to change the way you work</h2>
            <p>This is just something that works for us and we thought it would be cool to share.</p>
          </section>
        </section>
<!--
*** Beneficios ****

A different perspective.
 “Another set of eyes” adds objectivity.

Vision global :
Todos los miembros del equipo conocen, al menos por encima, como está hecho todo el proyecto

Evita fallos y regresiones:
Porque otro miembro del equipo revisa el código subido. Puede tener en cta algo que quizás no viste

Mejora el código
Siempre hay una forma de mejorar

Aumentan los conocimientos de los miembros del equipo
Alguien te puede enseñar algo nuevo

*** Inconvenientes ***

- Una primera impresion puede parecer que tienes más trabajo, el tuyo y la revisión del ocmpañero

- Al tener que ser revisado puede parecer que se tarda más en aterrizar algo


****** Antes de empezar ********
* Nos basamos en sprints (normalm 2 semanas)
- Producto nos dice que funcionalidades/requisitos quiere (user stories)
- Aportamos los comentarios que cosideremos oportunos a esas funcionalidades
- Acordadas las funcionalidades nos las prioriza
- Cada user story se determina las tareas necesarias para completarla
- El equipo estima el tiempo necesario para cada funcionalidad
- una user story debe entrar en un sprint, sino hay q partirlo
- Vemos cuantas funcionalidades podemos realizar en el sprint
- Durante el sprint los requisitos no deberían cambiar



* Cada miembro tiene su copia del proyecto (fork)
* tiene añadido como remoto el repositorio central
git remote add <nombreRepoCentral> url

* Cada vez q empieza una tarea parte de master
git checkout master
- Actualiza repo
git remote update
- Crea rama para la nueva tarea
git checkout -b TIC-XXX donde TIC es el id del proyecto y XXX el numero de tarea
- Realiza el trabajo y lo sube a su copia
git add <fichNecesarios>
git commit -m "[TIC-XXX] descripcion de lo hecho>
git push origin TIC-XXX

- Pide revision
hacer PR en github con r? @<idPeerReview>

**** Durante la revision *****
* El revisor hace una primera pasada viendo que cumple las reglas de estilo
 y que no hay fallos
* Realiza los test necesarios, comprueba que funciona y no tiene bugs
* solicita los cambios que considere oportuno, pregunta lo que no entienda (si es el caso)
* el revisado argumenta si considera oportuno xq ha implementado así la solucion
* se llega a un acuerdo de que cambiar
* realiza los cambios solicitados
* si los cambios fueron básicos, poco o muy claros informa de que está disponible
* si los cambios fueron significativos vuelve a solicitar review
* cuando se tiene el r+ el revisor mergea el pr

***** Varia tareas a la vez ****
Mientras una tarea está en review puedes empezar otra funcionalidad
se trata de coger una que no afecte a la funcionalidad en review
si no se puede o depende puedes hacer un cherry-pick
-->
        <section>
          <section>
					  <h2 class="fragment highlight-red">Starting from the beginning...</h2>
					  <h3 class="fragment roll-in">Why?!</h3>
          </section>
          <section>
            <h2>Because we can?</h2>
            <h3 class="fragment roll-in">No, seriously :)</h3>
            <h3 class="fragment roll-in">
				</section>
        <section>
          <section>
            <h2>So what can we do about this?</h2>
            <img height="400" src="imgs/Clueless Morgan.jpg" />
          </section>
          <section>
            <h3>Assume most people are harmless!</h3>
            <img src="imgs/1038.jpg"/>
            <h4 class="fragment roll-in">And give unsigned access to the APIs!</h4>
            <p class ="fragment roll-in">
              No, seriously!
            </p>
          </section>
          <section>
            <h3>But on a controlled way</h3>
            <p class ="fragment roll-in">
              You can breathe normally now
            </p>
            <p class ="fragment roll-in">
              Seriously, you were looking blue there for a moment!
            </p>
          </section>
        </section>
        
        <section>
          <section>
            <h1>Enter Mediators!</h1>
            <img src="imgs/Mediated API Request.png"/>
          </section>
          <section>
            <h3>The idea, take 1</h3>
            <h4 class ="fragment roll-in">Add a new class of system apps: mediators</h4>
            <img class="fragment roll-in" src="imgs/Basic Mediator.png"/>
            <p class="fragment roll-in">A mediator is a certified/signed app that has direct access to one or more APIs and exposes a mediated access to that API to unprivileged content.</p>
          </section>
          <section>
            <h3 class ="fragment roll-in">Client code</h3>
					  <pre class="fragment roll-in"><code data-trim>
navigator.connect(SETTINGS_SERVICE).then(port => {
  debug('Successfuly established connection to ' + SETTINGS_SERVICE);
  _port = port;
  port.onmessage = function (evt) {
    var handler = _getHandler(evt);
    if (!handler) {
      debug('Huh? Got an message with ' + JSON.stringify(evt.data) +
            ' that I don\'t know what to do with. Discarding!');
      return;
     }
    handler(evt.data);
  };
}
					</code></pre>
          </section>
          <section>
            <h3 class="fragment roll-in">Service code</h3>
					<pre class="fragment roll-in"><code data-trim>
this.onconnect = function(msg) {
  debug('SW onconnect: We should have a port here on msg.source. ' +
        (msg.source.postMessage ? 'yes!' : 'no :('));

  // TO-DO: This is not very secure... but we could, er should, control the origin here!
  msg.acceptConnection(true);

  var remotePort = msg.source;
  var myPortId = this._portId++;

  remotePort.onmessage = aMsg => {
    // TO-DO: We should implement access control here also!
    var requestId = aMsg.data.id;
    if (requestId) {
      debug('onmessage. Got Request:' + JSON.stringify(aMsg.data));
      // In sw APIS do not work!!!! We need to request it to the main thread

      this.channelToMT.then(channel => {
        // TO-DO: Multiplex the channel!
        channel.postMessage({remotePortId: myPortId, remoteData: aMsg.data});
      });
    } else {
      // Hmm...
      debug('onmessage: got a message without id');
    }
  };
};
					</code></pre>
          </section>
        </section>

        <section>
          <section>
            <h2>This is still way too complicated!</h2>
            <h3 class="fragment roll-in">And we already have APIs for all those things</h3>
          </section>
          <section>
            <h2>So let's just rewrite the APIs using this!</h2>
					<pre class="fragment roll-in"><code data-trim>
// This will have to be a SettingsManager object...
// Note that since mozSettings constructor is synchronous but we can't make
// this synchronous, this has an unfortunate difference where the object might
// disappear later.
window.navigator.mozSettings = {
  createLock: createLock,
  addObserver: addObserver,
  removeObserver: removeObserver
};

// Returns a SettingsLock object to safely access settings asynchronously.
// Note that the lock might be created and yet everything fail on it...
var createLock = function() {
  var lock = new FakeSettingsLock();
  navConnPromise.then(navConnHelper => navConnHelper.sendObject(lock));
  return lock;
};

// Allows to bind a function to any change on a given settings
var addObserver = function(setting, callback) {
  var observer = new Observer(callback);
  _observers[setting][callback] = observer;
  navConnPromise.then(navConnHelper => navConnHelper.sendObject(observer));
};

// Allows to unbind a function previously set with addObserver.
var removeObserver = function(setting, callback) {
  if (!_observers[setting][callback]) {
    return;
  }
  var obRemoval = new ObserverRemoval(_observers[setting][callback]);
  navConnPromise.then(navConnHelper => navConnHelper.sendObject(obRemoval));
  delete _observers[setting][callback];
};


					</code></pre>
          </section>
        </section>
        <section>
          <section>
            <h3>The idea, take 2</h3>
            <h4>Add push</h4>
            <p class="fragment roll-in">The same service worker/mediator can be installed on a FFOS device and a desktop app.</p>
            <p class="fragment roll-in">The actual API access will of course be available only on a FFOS device.</p>
            <p class="fragment roll-in">But it can be offered to desktop remotely!</p>
          </section>
          <section>
            <h4>Enrollment stage</h4>
            <img src="imgs/Initialization Mediated APIs.png"/>
          </section>
          <section>
            <ul>
              <li><b>Steps 1-3:</b> The first time the mediator is run on a device, it can get a push EndPoint and publish it to the server that hosts the mediator (that has a real URL!)</li>
              <li><b>Steps 4-6:</b> When the service is accessed through a desktop, it can get and register a push EndPoint (and link it to the same user that already has a device registered). How the actual link is done is out-of-scope, but Firefox Accounts might be used for this.</li>
            </ul>
          </section>
          <section>
            <h3>API usage stage</h3>
            <img src="imgs/Mediated API Request.png"/>
          </section>
          <section>
            <h4>Explanation</h4>
            <ul>
              <li><b>Steps 7-8:</b> A third party app wants to access some API that's available only on FFOS devices. It uses the polyfills (which will in turn use the mediator).</li>
              <li><b>Steps 9-11:</b> The mediator know it's not on a FFOS device, and so it sends the petition to the associated FFOS device (again, how the device is associated with an user is out-of-scope but FxA might be used). The actual petition is sent to the device using push.</li>
              <li><b>Steps 12-14:</b> The mediator on the device executes the functionality requested, and sends the data back to the desktop. Since the device doesn't know where the desktop is (or even if it is a desktop at all) it just sends the answer back to the server. </li>
              <li><b>Steps 15-18:</b> The server passes the answer back to the mediator service worker (using push again) which in turn passes it back to the calling third party application. </li>
            </ul>
          </section>
        </section>

        <section>
         <h3>Enter push</h3>
         <h4 class="fragment roll-in">And the only limit is your imagination!</h4>
         <p>
            <ol>
              <li class="fragment roll-in">Send SMS from your phone using your desktop browser?<span style="color: red;" class="fragment roll-in">: Gotcha!</span></li>
              <li class="fragment roll-in">Find/block your phone via SMS from your desktop?<span style="color: red;" class="fragment roll-in">: Why, yes!</span></li>
              <li class="fragment roll-in">Use the same phone specific (same code!) on the phone and desktop?<span style="color: red;" class="fragment roll-in">: Of course!</span></li>
              <li class="fragment roll-in">Write a *cough*Known IM service*cough* that uses SMS/phone/whatever to identify the user ?<span style="color: red;" class="fragment roll-in">: Yep!</span></li>
              <li class="fragment roll-in">Increase your success with your favorite sex?<span style="color: red;" class="fragment roll-in">: On the next version!</span></li>
            </ol>
         </p>
         <h3 class="fragment roll-in">And all of that without signing the app!</h3>
         <p class="fragment roll-in">It does <b>not</b> even have to be an app. Forget the manifest</p>
        </section>
				<section>
					<h2>Write once, run everywhere, do everything FFOS can do!</h2>
          <h3>It doesn't get sexier than that</h3>
				</section>
				<section>
					<h2>References and links</h2>
          <ol>
            <li> <b>navigator.connect polyfill</b> <a href="https://github.com/mcjimenez/nav_connect">https://github.com/mcjimenez/nav_connect/tree/usemessagechannel</a>. Requires MessageChannel working on workers (<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=911972">Bug 911972</a>)</li>
            <li> <b>WebAPIs polyfills (using navigator.connect)</b> <a href="https://github.com/AntonioMA/WebAPI_pf">https://github.com/AntonioMA/WebAPI_pf</a>. Requires either the navigator.connect polyfill or the real navigator.connect. Services require the developer mode to be enabled (to allow hosted certified apps).</li>
            <li> <b>Gaia radio app using Polyfills</b> <a href="https://github.com/telefonicaid/gaia/tree/hosted-web/apps/fm">https://github.com/telefonicaid/gaia/tree/hosted-web/apps/fm</a>. If using the polyfill, requires the MessageChannel patch, and developer_mode enabled </li>
          </ol>
				</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
